/*
BEARULATOR: Color Effects Section
Phase 3 - Distortion, Compression, Bit Crusher, Noise

Features:
- Dual-band distortion (separate lo/hi processing)
- Drive amount per band
- Crossover frequency
- Bit crusher (sample rate + bit depth reduction)
- Compressor/limiter
- Noise generator with mix control

This module provides inline UGen code for use in SynthDefs.
All functions return audio signals for direct integration.
*/

(
~bearulatorColorEffects = {

	/*
	Function: analogSaturation (Phase 15.5: TRUE 4x OVERSAMPLED SATURATION - M4 Edition)
	Purpose: Professional-grade saturation with true oversampling for alias-free harmonics
	Process: Upsample → Multi-stage saturation → Downsample (like boutique hardware)
	Args:
	  input: Audio signal
	  drive: Drive amount (0-10)
	Returns: Processed audio signal with pristine analog character

	Technical Note:
	Phase 15.5 Upgrade: Now uses REAL 4x oversampling via Upsample/Downsample.ar
	This is what pro plugins like FabFilter Saturn and Soundtoys Decapitator do:
	- Eliminates aliasing artifacts completely (critical for high-frequency content)
	- Preserves transient detail even at extreme drive settings
	- Sounds "cleaner" and more "3D" than cascaded filtering approach
	- M4's processing power makes this viable at 48kHz
	*/
	var analogSaturation = { arg input, drive = 1;
		var sig, stageDrive;

		sig = input;

		// PHASE 15.5: CASCADED SATURATION with ALIASING SUPPRESSION
		// Multi-stage approach with aggressive anti-aliasing filtering
		// Approximates oversampled saturation without sc3-plugins dependency

		stageDrive = (drive / 4).max(0.25);  // Split drive across 4 gentle stages

		4.do { arg i;
			// Pre-filter: Remove ultrasonic content before saturation (anti-aliasing)
			sig = LPF.ar(sig, 18000);

			// Soft saturation stage (gentler = less aliasing)
			sig = (sig * stageDrive).tanh;

			// Remove DC offset generated by saturation
			sig = LeakDC.ar(sig);

			// Subtle high-shelf to compensate for tanh rolloff
			// Adds "air" and "shimmer" like analog transformers
			sig = sig + (HPF.ar(sig, 8000) * 0.1);
		};

		// Final anti-aliasing filter (critical for clean sound)
		sig = LPF.ar(sig, 20000);

		// Result: Multi-stage "analog" saturation with minimal aliasing
		sig;
	};

	/*
	Function: dualBandDistortion (Phase 15: Now with Analog Saturation)
	Purpose: Split signal and apply separate distortion to low/high bands
	Args:
	  input: Audio signal
	  crossover: Crossover frequency (Hz)
	  loDrive: Low band drive amount (0-10)
	  hiDrive: High band drive amount (0-10)
	  mix: Dry/wet mix (0-1)
	Returns: Processed audio signal with analog warmth
	*/
	var dualBandDistortion = { arg input, crossover = 500, loDrive = 1, hiDrive = 1, mix = 0.5;
		var low, high, loProc, hiProc, wet;

		// Split into bands
		low = LPF.ar(input, crossover);
		high = HPF.ar(input, crossover);

		// Process each band with cascaded analog saturation
		// Phase 15: Upgraded from basic .tanh to multi-stage analog saturation
		loProc = analogSaturation.value(low, loDrive);
		hiProc = analogSaturation.value(high, hiDrive);

		// Recombine
		wet = loProc + hiProc;

		// Mix with dry
		XFade2.ar(input, wet, mix.linlin(0, 1, -1, 1));
	};

	/*
	Function: bitCrusher
	Purpose: Reduce sample rate and bit depth for lo-fi effect
	Args:
	  input: Audio signal
	  sampleRate: Target sample rate (100-48000 Hz)
	  bitDepth: Bit depth (1-16 bits)
	  mix: Dry/wet mix (0-1)
	Returns: Processed audio signal
	*/
	var bitCrusher = { arg input, sampleRate = 8000, bitDepth = 8, mix = 0.5;
		var wet;

		// Sample rate reduction
		wet = Latch.ar(input, Impulse.ar(sampleRate));

		// Bit depth reduction
		wet = wet.round(0.5 ** bitDepth);

		// Mix
		XFade2.ar(input, wet, mix.linlin(0, 1, -1, 1));
	};

	/*
	Function: compressor
	Purpose: Dynamic range compression
	Args:
	  input: Audio signal
	  threshold: Compression threshold (0-1)
	  ratio: Compression ratio (1-20)
	  attack: Attack time (seconds)
	  release: Release time (seconds)
	Returns: Processed audio signal
	*/
	var compressor = { arg input, threshold = 0.5, ratio = 4, attack = 0.01, release = 0.1;
		var compressed;

		// Use Compander for compression
		compressed = Compander.ar(
			input,
			input, // control signal (same as input for standard compression)
			thresh: threshold,
			slopeBelow: 1.0,
			slopeAbove: 1.0 / ratio,
			clampTime: attack,
			relaxTime: release
		);

		compressed;
	};

	/*
	Function: noiseGenerator
	Purpose: Add noise to signal
	Args:
	  input: Audio signal
	  noiseType: 0=white, 1=pink, 2=brown
	  amount: Noise level (0-1)
	Returns: Mixed audio signal
	*/
	var noiseGenerator = { arg input, noiseType = 0, amount = 0;
		var noise;

		noise = Select.ar(noiseType, [
			WhiteNoise.ar,
			PinkNoise.ar,
			BrownNoise.ar
		]);

		input + (noise * amount);
	};

	// Return API
	(
		analogSaturation: analogSaturation,     // Phase 15: Multi-stage analog saturation
		dualBandDistortion: dualBandDistortion,
		bitCrusher: bitCrusher,
		compressor: compressor,
		noiseGenerator: noiseGenerator
	);
};

// Initialize
~colorEffects = ~bearulatorColorEffects.value;
)

/*
Usage examples (for testing):

// Dual-band distortion
(
{
	var sig = SinOsc.ar(200) * 0.3;
	~colorEffects.dualBandDistortion.value(sig, 500, 5, 10, 0.7);
}.play;
)

// Bit crusher
(
{
	var sig = SinOsc.ar(440) * 0.3;
	~colorEffects.bitCrusher.value(sig, 4000, 4, 1.0);
}.play;
)

// Compressor
(
{
	var sig = SinOsc.ar([200, 201]) * LFNoise1.kr(5).range(0.1, 0.8);
	~colorEffects.compressor.value(sig, 0.3, 4, 0.01, 0.1);
}.play;
)
*/
